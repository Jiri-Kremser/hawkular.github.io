= Hawkular Alerts for Developers
Jay Shaughnessy
2015-04-24
:description: Hawkular Alerts Developer Guide
:icons: font
:jbake-type: page
:jbake-status: published
:toc: macro
:toc-title:

toc::[]

== Introduction

Hawkular Alerts is a component of the http://hawkular.org[Hawkular] management and monitoring project. It's goal is to provide flexible and scalable alerting services in an easily consumable way.

The Hawkular Alerts project lives on http://github.com/hawkular/hawkular-alerts[GitHub].

=== Alerting Philosophy

Alerting is useful, necessary, and typically an integral part of operational sanity.  Done well it strikes the perfect balance between human intervention and automation.  Done poorly it is an ineffective nuisance.  Hawkular Alerts tries to provide the tools to do things well, but it can just as easily be abused.  Alerts bring attention to a problem, or developing problem.  That problem typically requires human intervention to resolve.  As best as possible the alert should represent high level symptoms that affect a user experience.  The number of generated alerts should be small because a human can only respond to a few situations daily.  The same alert should likely not be repeated, or repeated only if a response has not been initiated.

==== Alerts

Alerts are generated when an Alert Trigger fires, based on a set of defined conditions that have been matched, possibly more than once or have held true over a period of time. When fired the trigger can perform actions, typically but not limited to notifications (e-mail, sms, etc). Alerts then start moving through the Open, Acknowledged, Resolved life-cycle.  There are many options on triggers to help ensure that alerts are not generated too frequently, including ways of automatically disabling and enabling the trigger.

==== Events (Since 0.6.0.Final)

As discussed abovem the number of alerts should be small in order to be manageable.  But it can be useful to capture interesting happenings in the monitored world. This is called an Event in Hawkular Alerts.  An event can be roughly thought of as an alert without lifecycle.  Like alerts, an event can be generated by a trigger but unlike an alert, it can also be injected directly via the API, so it is very easy for clients to insert events as desired.  And although trigger-generated events can define actions to be performed, in general an event does not need human intervention.  Instead, it is typically something that can contribute to an alert firing, help investigate an alert, or simply help understand system behavior.

It is expected that the number of Events can be very large compared to the number of Alerts. Events (like Alerts), can be flexibly queried.


== Triggers

A Trigger defines the conditions that when satisfied will cause the trigger to fire an Alert.  Triggers can have one or more conditions and can optionally fire when ANY or ALL of the conditions are met. A trigger can generate an Alert or an Event.


=== Conditions

There are several different kinds of conditions but they all have one thing in common, each requires some piece of data against which the condition is evaluated.  Here are the different kinds of conditions:

* Threshold
** X < 10, X >= 20
* ThresholdRange
** X inside [10,20), X outside [100,200]
* Compare
** X < 80% Y
* String
** X starts with "ABC", X matches "A.*B"
* Availability
** X is DOWN

Most conditions deal with numeric data.  But String and Availability data is also supported.  A trigger can combine conditions dealing with data of different types and from different sources.


=== Actions

The whole purpose of alerting is to be able to immediately respond to a developing or active problem.  Hawkular Alerts provides several plugins to take action when alerts are generated.  Custom action plugins can be defined as well. The list of provided action plugins keeps growing, Here is a sample:

* E-mail notification
* SMS notification
* SNMP notification
* Pager Duty integration
* Aerogear integration
* File-system notification
* Webhook notification


=== Trigger Dampening

It's often the case that you don't want a trigger to fire every time a condition set is met.  Instead, you want to ensure that the issue is not a spike of activity, or that you don't flood an on-call engineer with alerts.  Hawkular Alerts provides several way of ensuring triggers fire only as desired. We call this "_Trigger Dampening_".  An example is useful for understanding dampening.  

Let's say we have a trigger with a single condition: responseTime > 1s.

It is important to understand how the reporting interval plays into alerting, and into dampening.  Assume responseTime is reported every 15s.  That means we get roughly 4 data points every minute, and therefore evaluate the condition around 4 times a minute.

Here are the different trigger dampening types:

==== Strict
* N consecutive true evaluations
* Useful for ignoring spikes in activity or waiting for a prolonged event

In our example this could be, "Fire the trigger only if responseTime > 1s for 6 consecutive evaluations".  So, given a 15s reporting interval this means response time would likely have been high for about 90s.  But note that if the reporting interval changes the firing time will change.  This is used more when the number of evaluations is more important than the time it takes to fire.

Note that default dampening for triggers is Strict(1).  Which just means that by default a trigger fires every time it's condition set evaluates to true.

==== Relaxed Count
* N true evaluations out of M total evaluations
* Useful for ignoring short spikes in activity but catching frequently spiking activity

In our example this could be, "Fire the trigger only if responseTime > 1s for 4 of 8 evaluations".  This means the trigger will fire if roughly half the time we are exceeding a 1s response time.  Given a 15s reporting interval this means the trigger could fire in 1 to 2 minutes of accumulated evaluations. But note that if the reporting interval changes the firing time will change.  This is used more when the number of evaluations is more important than the time it takes to fire.

==== Relaxed Time
* N true evaluations in T time
* Useful for ignoring short spikes in activity but catching frequently spiking activity

In our example this could be, "Fire the trigger only if responseTime > 1s 4 times in 5 minutes".  This means the trigger will fire if we exceed 1s response time multiple times in a 5 minute period. Given a 15s reporting interval this means the trigger could fire in 1 to 5 minutes of accumulated evaluations. But note that if the reporting interval changes the firing time will change. And also note that the trigger will never fire if we don't receive at least 4 reports in the specified 5 minute period. This is used when you don't want to exceed a certain period of time before firing.

==== Strict Time
* Only true evaluations for at least T time
* Useful for reporting a continued aberration

In our example this could be, "Fire the trigger only if responseTime > 1s for at least 5 minutes".  This means the trigger will fire if we exceed 1s response time on every report for a 5 minute period. Given a 15s reporting interval this means the trigger will fire after roughly 20 consecutive true evaluations. Note that if the reporting interval changes the firing time will remain roughly the same.  It is important to understand that at least 2 evaluations are required.  The first true evaluation starts the clock. Any false evaluation stops the clock. Assuming only true evaluations, the trigger fires on the first true evaluation at or after the specified period.  The shorter the reporting interval the closer the firing time will be to the specified period, T.

==== Strict Timeout
* Only true evaluations for T time
* Useful for reporting a continued aberration with a more guaranteed firing time

In our example this could be, "Fire the trigger only if responseTime > 1s for 5 minutes".  This means the trigger will fire if we exceed 1s response time on every report for a 5 minute period. Given a 15s reporting interval this means the trigger will fire after roughly 20 consecutive true evaluations. Note that if the reporting interval changes the firing time will remain the same.  It is important to understand that only 1 evaluation is required.  The first true evaluation starts the clock. Assuming only true evaluations, the trigger fires at T, when a timer expires and fires the trigger. Any false evaluation stops the clock and cancels the timer. This type of dampening has more processing overhead because the trigger evaluation requires an external timer.

=== AutoDisable

A trigger can be set for AutoDisable.  Whereas dampening can limit the firing rate of a trigger, disabling a trigger completely stops the trigger from firing (or being evaluated).  A trigger can be manually enabled and disabled, via the REST API, but it can also be disabled automatically. If the trigger has the autoDisable option set to true then after it fires it id disabled, preventing any subsequent alerts until manually re-enabled.  The default is false.

=== AutoEnable

A trigger can be set for AutoEnable.  If AutoEnable is true then when an alert is resolved, and if all alerts for the trigger are then resolved, the trigger will be enabled if it is currently disabled.  This ensures that the trigger will again go into firing mode, without needing to be manually enabled by the user. The default is false.


== Alert Lifecycle

Hawkular Alerts can integrate with other systems to handle Alert Lifecycle, but alerts can also be managed directly within the tool.  Hawkular Alerts supports a typical move through a simple lifecycle.  An alert starts in OPEN status, optionally moves to ACKNOWLEDGED to indicate the alert has been seen and the issue is being resolved, and is finally set to RESOLVED to indicate the problem has been fixed.

=== AutoResolve

Triggers require firing conditions and always start in _Firing_ mode.  But the trigger can optionally supply autoResolve conditions. If _autoResolve=true_ then after a trigger fires it switches to _AutoResolve_ mode.  In AutoResolve mode the trigger no longer looks for problem conditions, but instead looks for evidence that the problem is resolved.  A simple example would be a trigger that has a firing condition of Availability DOWN, and an autoResolve condition of Availability UP.  This mechanism ensures that only one alert is generated for a problem, and that when the problem has been resolved, the trigger automatically returns to firing mode.

Moreover, if _autoResolveAlerts=true_ then when the AutoResolve conditions are satisfied all of its unresolved alerts will be automatically set RESOLVED.

Like Firing mode, AutoResolveMode can optionally define its own dampening setting.


== Tags

Tags can have a variety of uses but are commonly used to assist in search.  Tags are free-formed name-value pairs and can be applied to:
* Triggers
* Alerts
* Events

Tags on triggers are automatically passed on to the Alerts or Events generated by that trigger.  This allows the same search criteria used to fetch triggers to also be used to fetch the alerts or events generated by those triggers.

A tag's name and value must both be non-empty.  But tag search allows for matching just the name by specifying value='*' in the search criteria.


== REST API

Hawkular Alerts supports a robust REST API for managing Triggers, Alerts and Events.  For more on how to generate API documentation, see the README.adoc at http://github.com/hawkular/hawkular-alerts[Hawkular-Alerts @ *GitHub*].


== External Alert Integration

There are times when an external system will already be looking for and detecting potential issues in its environment.  It is possible for these detection-only systems to leverage the power of Hawkular Alerts' trigger and action infrastructure.  For example, let's say there is already a sensor in place looking for overheating situations.  When it detects something overheating it can take some action.  In this case we are not sending a stream of heat readings to alerting and having it evaluate against a threshold set on a trigger condition.  Instead, the threshold and evaluation are all built into the sensor.  To integrate with Hawkular Alerts we can use an "External Condition".

=== External Conditions

External integration begins with standard triggers.  In this way we immediately get everything that triggers offer: actions, dampening, lifecycle, auto-resolve, etc.  The difference is that instead of the typical condition types: Threshold, Availability, etc.., we can use an ExternalCondition. An external condition is like other conditions in that it has a 'dataId' with which it matches data sent into Hawkular Alerts.  It also has 'systemId' and 'expression' fields. The systemId is used to identify the external system for which the condition is relevant. In our example, perhaps "HeatSensors".  The expression field is used as needed.  In our example it may not be needed or it could be a description like, "sensor detected high temperature".  In other examples it could be used to store a complex expression that will be evaluated by the external system. 

The main thing about external conditions is that they always evaluate to true.  It is assumed that when a datum comes in with a dataId assigned to an external condition that that condition immediately evaluates to true.  A trigger with a single external condition (and default dampening) would fire on every datum sent in for it's condition.  This is because it is assumed the external system already did the work of determining there was an issue.  

Note that the string data sent in has any value the external alerter system wants it to be.  In our example it may  be a sensorId and temperature, like "Sensor 5368, temperature 212F".


== Actions Plugins

Plugins are responsible to execute actions when an alert, or possibly an event, happens.

Actions can be a notification task or a complex process.

Hawkular Alerts provide a plugin architecture to extend and add new behaviours.

=== Create a new plugin

We can add a new plugin in hawkular in several steps:

* Create a new project under `hawkular-alerts-actions-plugins`.

TIP: You can use an existing one as a template i.e. `hawkular-alerts-actions-file`

* Add an implementation of `org.hawkular.alerts.actions.api.ActionPluginListener` interface.

* Add a plugin name to the implementation with the `org.hawkular.alerts.actions.api.ActionPlugin` annotation.

For example:

[source,java]
----
@ActionPlugin(name = "file")
public class FilePlugin implements ActionPluginListener {
    ...
}
----

=== ActionPluginListener interface

This interface has the responsability of

* Define which properties and default values are supported by a plugin

[source,java]
----
...
    /**
     * The alerts engine registers the plugins available with their properties.
     * This method is invoked at plugin registration time.
     *
     * @return a list of properties available on this plugin
     */
    Set<String> getProperties();

    /**
     * The alerts engine registers the plugins available with their default values.
     * This method is invoked at plugin registration time.
     * Default values can be modified by the alerts engine.
     *
     *
     * @return a list of default values for properties available on this plugin
     */
    Map<String, String> getDefaultProperties();
...
----

* Process an incoming action message wrapped as a `org.hawkular.alerts.actions.api.ActionMessage`

[source,java]
----
...
    /**
     * This method is invoked by the ActionService to process a new action generated by the engine.
     *
     * @param msg message received to be processed by the plugin
     * @throws Exception any problem
     */
    void process(ActionMessage msg) throws Exception;
...
----

=== ActionMessage interface

This interface is a wrapper of the action sent by the engine with the effective properties to use by the plugin to
process it.

[source,java]
----
package org.hawkular.alerts.actions.api;

import java.util.Map;

import org.hawkular.alerts.api.model.action.Action;

import com.fasterxml.jackson.annotation.JsonInclude;

/**
 * A message sent to the plugin from the alerts engine
 * It has the event payload as well as action properties
 *
 * @author Lucas Ponce
 */
public interface ActionMessage {

    @JsonInclude
    Action getAction();
}
----

The class `org.hawkular.alerts.api.model.action.Action` is generated for the engine and it has the event detail as
part of its payload.

[source,java]
----
/**
 * A base class for action representation from the perspective of the alerts engine.
 * An action is the abstract concept of a consequence of an event.
 * A Trigger definition can be linked with a list of actions.
 *
 * Alert engine only needs to know an action id and message/payload.
 * Action payload can optionally have an event as payload.
 *
 * Action plugins will be responsible to process the action according its own plugin configuration.
 *
 * @author Jay Shaughnessy
 * @author Lucas Ponce
 */
public class Action {

    @JsonInclude
    private String tenantId;

    @JsonInclude
    private String actionPlugin;

    @JsonInclude
    private String actionId;

    @JsonInclude(Include.NON_NULL)
    private String eventId;
...
}
----
